# Axiomatic Color - AI Context

This file contains a condensed overview of the Axiomatic Color system, designed for LLMs.

## Axioms (The Constitution)

# The Constitution (Axioms)

> **Status**: Living Document
> **Version**: 1.2 (Epoch 19)

This document serves as the "Constitution" for Axiomatic Color. It consolidates the core philosophy, physical laws, and architectural rules that govern the system. All design decisions and code changes must align with these axioms.

## I. The Prime Directive

**Accessibility is the Foundation of Aesthetics.**

A design cannot be beautiful if it cannot be perceived. We reject the idea that accessibility and aesthetics are in conflict; instead, we treat accessibility as the physical medium upon which beauty is built.

- **Constraint, not Feature**: Accessibility is not a "nice to have" or a compliance checklist item. It is the mathematical constraint solver that generates the palette.
- **Universal Perception**: We design for the human eye in all its variations (aging, color blindness, low vision), not just the designer's monitor.

## II. The Laws of Physics (Light)

These axioms describe how the system models light and color perception.

### 1. Lightness is Relative

A surface's lightness is never absolute; it is defined by its **Context**.

- **Polarity**: A "light" surface in a dark mode context is actually dark. A "dark" surface in a light mode context is actually light.
- **Adaptation**: The system solves for _contrast ratios_, not hex codes. `Surface-100` might be white in one theme and black in another, but its relationship to its content remains constant.

### 2. Chroma is Expensive

High chroma (saturation) reduces available lightness contrast.

- **The Trade-off**: You cannot have a color that is both extremely vibrant and extremely accessible against all backgrounds.
- **Budgeting**: Every surface has a "chroma budget". Spending it on vibrancy means you have less room for lightness variation.

### 3. Hue Rotates (The Bezold-Brücke Effect)

Hue is not static across the lightness spectrum.

- **Natural Shift**: As colors get lighter or darker, our perception of their hue shifts. A linear ramp of "Blue" often looks purple in the darks or teal in the lights.
- **Non-Linear Correction**: The system uses cubic Bezier curves to rotate hue non-linearly, mimicking natural light physics (cool shadows → warm highlights) to maintain perceptual harmony.
- **Reference**: See [Hue Shift Rationale](hue-shift.md) for the mathematical implementation.

## III. The Laws of Architecture (Surfaces)

These axioms describe how the system organizes UI elements.

### 4. Surfaces are Containers

Every visible element lives on a **Surface**.

- **No Floating Content**: Text, icons, and borders never exist in a vacuum. They are always "on" something.
- **Taxonomy**:
  - **Canvas**: The infinite backdrop (`page`, `workspace`).
  - **Object**: A contained element (`card`, `tinted`).
  - **Action**: An interactive element (`action`).
  - **Spotlight**: A high-emphasis element (`spotlight`).

### 5. Context Flows Down

A surface establishes the **Context** for its children.

- **Inheritance**: When you nest a Card on a Page, the Card consumes the Page's context and creates a new context for its contents.
- **Automatic Adjustment**: The system automatically adjusts contrast and polarity based on the nesting level. You don't manually pick "Dark Card" or "Light Card"; you just pick "Card".

### 6. Text is Relative

Text color is defined by the surface it sits on, not by global variables.

- **Context Consumers**: Text tokens (`text-strong`, `text-subtle`) are abstract requests for contrast.
- **Inversion**: `text-strong` on a light surface is dark. `text-strong` on a dark surface is light. The component doesn't know or care; it just asks for "Strong Text".

## IV. The Laws of Integration

These axioms describe how the system interacts with the world.

### 7. The Code is the Source of Truth

Design tools (Figma, Sketch) are downstream consumers of the code, not the other way around.

- **Generation**: Tokens are generated from the configuration code.
- **No Manual Tweaks**: We do not manually tweak individual hex codes in the output. If a color looks wrong, we adjust the _algorithm_ or the _configuration constraints_.
- **Isomorphism**: The core logic (`src/lib`) is isomorphic. It runs identically in Node.js (CLI) and the Browser (Theme Builder), ensuring the preview always matches the build output.

### 8. No Magic Numbers

All values are derived from the configuration (Anchors, Curves).

- **Math vs. Magic**: We reject arbitrary values like "Blue-500".
- **Derivation**: Every color is the result of a solver function: `f(Context, Intent) = Color`.

### 9. Baseline Newly Available

We build for the modern web, not the legacy web.

- **Policy**: We adopt features that are "Newly Available" in major browsers (last 2 versions). We do not burden the codebase with polyfills or fallbacks for obsolete browsers unless strictly necessary.
- **Examples**: `oklch()`, `light-dark()`, `@property`, `popover`.

## V. The Laws of Engineering

These axioms describe how we build the software itself.

### 10. State is a Domain Model

We model application state using plain classes and Runes, not framework-specific boilerplate.

- **Encapsulation**: Logic lives in `*.svelte.ts` classes, not in UI components.
- **Reactivity**: We use fine-grained reactivity (`$state`, `$derived`) to track changes automatically.
- **Injection**: State is injected via Context, avoiding global singletons and ensuring testability.
- **Reference**: See [State Architecture](state-architecture.md).

### 11. Testing is a Ratchet

We do not just maintain quality; we actively increase it with every change.

- **No Regression**: Coverage thresholds are a floor, not a ceiling. We never lower them.
- **New Code, New Tests**: Every new feature or bug fix must include accompanying tests.
- **Coverage Growth**: We aim to increase test coverage over time, treating low coverage as technical debt to be paid down.

### 12. The Law of Late Binding

Color is a Function, Not a Value.

- **Dynamic Resolution**: Final pixel values are resolved at the last possible moment by the engine.
- **Indirection**: Utilities never set properties directly; they modify the _inputs_ to the engine's calculation.
- **Composition**: Primitive tokens are exposed as class-based utilities that modify orthogonal inputs (e.g., Lightness vs. Hue), allowing them to be composed naturally without conflict.

---

## Thinking in Surfaces

<DemoWrapper>

**Static palettes are not enough for modern interfaces.**

In a dynamic UI, colors change based on where they live. A "gray" text needs to be dark on a white card, but light on a dark tooltip.

Axiomatic Color acts as a **Context Engine**. Instead of giving you a fixed list of colors, it gives you **Surfaces** that automatically adjust their content to fit the environment.

## The Core Concept

A **Surface** is not just a background color. It **sets the rules** for everything inside it.

When you place an element on a surface, you aren't just painting pixels. You are entering a new **Context**.

### 1. Surfaces Create Context

Every surface acts as a "Context Provider." It automatically sets a suite of CSS variables that determine how text, borders, and other elements should look _when sitting on that specific surface_.

<Diagram>
  <div class="mb-4 text-sm text-text-subtle">
    Click on any surface below to inspect its active tokens.
  </div>
  <ContextVisualizer client:load />
</Diagram>

In the visualization above:

1.  The **Page** sets the baseline context (Light Mode).
2.  The **Card** sits on the Page. It might be slightly lighter or darker, but it maintains the same "Polarity" (Light text on Dark, or Dark text on Light).
3.  The **Spotlight** (the dark box) _inverts_ the polarity. It tells its children: "I am dark. You must be light."

### 2. Content Adapts to Context

Because of this architecture, your components become **portable**.

You don't write CSS like `.card .text` or `.footer .text`. You just write `.text-strong`.

- If `.text-strong` is on a white card, it resolves to black.
- If `.text-strong` is on a black tooltip, it resolves to white.

The component doesn't know where it is. The _Surface_ tells it how to render.

## The Hierarchy of Surfaces

We categorize surfaces based on their physical role in the UI, not their color.

### The Canvas

These are the foundations. They recede into the background.

- **Page**: The infinite backdrop.
- **Workspace**: A dedicated area for tools or navigation.

### The Objects

These sit _on top_ of the canvas. They hold your content.

- **Card**: The primary container for information.
- **Tinted**: A subtle grouping mechanism, often used to highlight a section without a hard border.

### The Interactors

These are actionable. They invite touch.

- **Action**: Buttons, toggles, and controls.

### The Spotlights

These demand attention. They often break the current polarity to stand out.

- **Spotlight**: Tooltips, toasts, and primary calls-to-action.

**Note on Inversion**: Spotlight surfaces perform a "Hard Flip" of the theme. If your app is in Light Mode, a Spotlight surface forces its internals into Dark Mode (and vice versa). This ensures that native browser controls (like scrollbars and checkboxes) render correctly inside the inverted area.

## Why This Matters

By thinking in surfaces, you stop fighting with contrast ratios.

1.  **Guaranteed Contrast**: The system calculates the foreground colors based on the background surface. If the surface changes, the text changes.
2.  **Automatic Dark Mode**: You don't design "Dark Mode" separately. You just define your surfaces, and the system flips the context.
3.  **Infinite Nesting**: You can put a Card inside a Sidebar inside a Page. The system handles the math to ensure distinctness at every level.

</DemoWrapper>

---

## Accessibility First

In most design systems, accessibility is a step you take _after_ you choose your colors. You pick a palette, check the contrast ratios, and then tweak them until they pass.

In the Axiomatic Color, accessibility is the **input**, not the output.

## The Solver is an Accessibility Engine

When you configure the system, you don't say "I want this specific shade of gray for my text."

You say: **"I want my text to be readable."**

The solver takes that intent and calculates the exact lightness value needed to achieve it. If it's mathematically impossible to achieve that contrast with your current background color, the solver will warn you or adjust the background to make it work.

### APCA: The Future of Contrast

We use the **Advanced Perceptual Contrast Algorithm (APCA)**, the candidate method for WCAG 3.0.

Old contrast ratios (like 4.5:1) are simple math, but they don't match how human eyes work. They often fail to predict readability in Dark Mode.

APCA models **human perception**. It understands that:

1.  **Polarity Matters**: White text on black looks different than black text on white.
2.  **Weight Matters**: Thinner fonts need more contrast than bold fonts.
3.  **Context Matters**: The surrounding light affects how you see a specific element.

By using APCA, the system ensures your text is _actually_ readable, not just technically compliant.

### Mapping APCA to WCAG 2.1

While APCA is the future, we understand that many teams are legally required to meet WCAG 2.1 standards (AA or AAA).




The Axiomatic Color targets APCA values that **exceed** standard WCAG requirements. Here is a rough equivalence guide for compliance auditing:

<Diagram>
  <TokenLevelVisualizer />
</Diagram>

> **Note:** Because APCA is context-aware, these mappings are approximations. However, our baseline target of $L^c 75$ for even the subtlest text ensures that you are safely within the "accessible" range for almost all use cases.

## Automated High Contrast

Some users need more than just "good" contrast. They need **High Contrast**.

Usually, supporting this requires a separate "High Contrast Theme" that you have to maintain manually.

The Axiomatic Color generates this for you automatically. When you build your theme, it creates a `@media (prefers-contrast: more)` block that:

1.  **Maximizes Range**: Pushes the Page background to pure Black/White.
2.  **Increases Contrast**: Bumps up the target contrast ratios for all text.
3.  **Reduces Noise**: Desaturates colors to reduce visual vibration.

The browser applies this automatically based on the user's OS settings.

## Forced Colors (Windows High Contrast)

For users with severe visual impairments who use "Forced Colors Mode" (like on Windows), the system maps your semantic surfaces to system colors.

| Surface          | Maps To      |
| :--------------- | :----------- |
| `surface-card`   | `Canvas`     |
| `text-strong`    | `CanvasText` |
| `surface-action` | `ButtonFace` |
| `text-link`      | `LinkText`   |
| `state-selected` | `Highlight`  |

This ensures that your app behaves like a native application for users who rely on these tools.

## Print is an Accessibility Feature

We treat "Print" as just another mode.

When a user prints your page, the system:

1.  **Forces Light Mode**: To save ink and ensure legibility on paper.
2.  **Removes Backgrounds**: Sets backgrounds to `white` (paper color).
3.  **Adds Borders**: Since backgrounds are gone, it adds borders to `surface-card` and other containers so the structure remains visible.

You don't need to write a print stylesheet. The system's "Physics" just adapt to the medium of "Ink on Paper."

---

## Quick Start

This guide will walk you through setting up the Axiomatic Color and building your first themed component.

## 1. Install & Initialize

Run the following commands in your project root:


  
    ```bash npm install -D @axiomatic-design/color npx axiomatic init ```
  
  
    ```bash pnpm add -D @axiomatic-design/color pnpm exec axiomatic init ```
  


This creates a `color-config.json` file with default settings.

## 2. Generate Assets

Now, generate the CSS and TypeScript definitions.


  
    ```bash npx axiomatic build --out ./src/theme.css npx axiomatic export
    --format typescript --out ./src/theme.ts ```
  
  
    ```bash pnpm exec axiomatic build --out ./src/theme.css pnpm exec axiomatic
    export --format typescript --out ./src/theme.ts ```
  


## 3. Build a Card

Let's build a simple "Card" component to see the system in action.


  
  
  First, import the CSS in your app entry point:
  ```tsx
  import './theme.css';
  ```

Then, create a Card component:

```tsx


export function Card() {
  return (
    <div
      className={tokens.surface.card}
      style={{ padding: "2rem", borderRadius: "8px" }}
    >
      <h2 style={{ color: tokens.context.text.high }}>Hello World</h2>
      <p style={{ color: tokens.context.text.subtle }}>I am a themed card.</p>
    </div>
  );
}
```

  

  
  
  First, import the CSS in your root layout:
  ```svelte
  <script>
    import '../theme.css';
  </script>
  <slot />
  ```

Then, create a Card component:

```svelte
<script>
  import { tokens } from "$lib/theme";
</script>

<div class={tokens.surface.card} style="padding: 2rem; border-radius: 8px;">
  <h2 style="color: {tokens.context.text.high}">Hello World</h2>
  <p style="color: {tokens.context.text.subtle}">I am a themed card.</p>
</div>
```

  

  
  
  Link the CSS in your `<head>`:
  
  > **Note**: If you are using a bundler (like Vite, Webpack, or Astro), you should import the CSS file in your JavaScript/TypeScript entry point instead (e.g. `import './theme.css'`).

```html
<link rel="stylesheet" href="/theme.css" />
```

Then, write the markup using the utility classes:

```html
<div class="surface-card" style="padding: 2rem; border-radius: 8px;">
  <h2 class="text-strong">Hello World</h2>
  <p class="text-subtle">I am a themed card.</p>
</div>
```

  


## 4. Next Steps

You now have a working theme system!

- **[React Integration](./frameworks/react)**: Deep dive into React patterns.
- **[Svelte Integration](./frameworks/svelte)**: Deep dive into Svelte patterns.
- **[The Theme Studio](./theme-builder)**: Customize your colors visually.

---

## CLI Reference

The `axiomatic` CLI is the primary tool for generating your theme tokens.

## Installation

```bash
pnpm add -D @axiomatic-design/color
# or
npm install -D @axiomatic-design/color
```

## Usage

```bash
npx axiomatic [command] [options]
```

## Commands

### `init`

Scaffolds a new configuration file in your project.

```bash
npx axiomatic init
```

**Behavior:**

- Checks if `color-config.json` exists.
- If not, creates it with the default configuration.
- If it exists, exits with an error to prevent overwriting.

### `generate` (Default)

Generates the CSS tokens based on your configuration. If no command is specified, this is the default behavior.

```bash
npx axiomatic [config-file] [output-file]
```

**Arguments:**

1.  **`config-file`** (Optional)

    - Path to your JSON configuration file.
    - **Default**: `./color-config.json`

2.  **`output-file`** (Optional)
    - Path where the generated CSS will be written.
    - **Default**: `./theme.css`

**Examples:**

```bash
# Use defaults
npx axiomatic

# Custom config, default output
npx axiomatic ./design/my-colors.json

# Custom config and output
npx axiomatic ./design/my-colors.json ./src/styles/variables.css
```

## Output

The CLI generates a CSS file containing:

1.  **:root Variables**: Global tokens like shadows, focus rings, and data viz colors.
2.  **Surface Classes**: Classes for each surface defined in your config (e.g., `.surface-card`).
3.  **High Contrast Media Query**: A `@media (prefers-contrast: more)` block with accessible overrides.

### Integration

Import the generated file in your main CSS entry point:

```css
@import "./theme.css";
```

---

## JavaScript API

The Runtime API allows you to manage the theme mode and sync it with the browser environment.

## `ThemeManager`

The `ThemeManager` class is the main entry point for runtime theme control.

```typescript

```

### Constructor

```typescript
const themeManager = new ThemeManager(options?: ThemeManagerOptions);
```

**Options:**

| Option             | Type                        | Default                    | Description                                                                 |
| :----------------- | :-------------------------- | :------------------------- | :-------------------------------------------------------------------------- |
| `root`             | `HTMLElement`               | `document.documentElement` | The element to apply the theme to.                                          |
| `lightClass`       | `string`                    | `undefined`                | Class to add in light mode. If omitted, sets `style="color-scheme: light"`. |
| `darkClass`        | `string`                    | `undefined`                | Class to add in dark mode. If omitted, sets `style="color-scheme: dark"`.   |
| `faviconGenerator` | `(color: string) => string` | `undefined`                | Function to generate an SVG favicon based on the current theme color.       |

### Methods

#### `setMode(mode: ThemeMode)`

Sets the active theme mode.

- **`mode`**: `"light" | "dark" | "system"`

```typescript
themeManager.setMode("dark");
```

#### `get mode()`

Returns the current configured mode (e.g., `"system"`).

#### `get resolvedMode()`

Returns the actual active mode (`"light"` or `"dark"`). If mode is `"system"`, this returns the OS preference.

#### `dispose()`

Cleans up event listeners (e.g., for system preference changes). Call this when unmounting your app or component.

### Interaction with Inverted Surfaces

The `ThemeManager` sets the global theme state on the root element. The generated CSS uses this state to automatically flip the `color-scheme` for inverted surfaces (like `surface-spotlight`).

No extra JavaScript is required to handle these local inversions.

## Helper Functions

### `updateThemeColor()`

Updates the `<meta name="theme-color">` tag to match the computed background color of the document body. This is called automatically by `ThemeManager`, but you can export and use it manually if needed.

```typescript


updateThemeColor();
```

### `updateFavicon(generator)`

Updates the favicon dynamically.

```typescript


updateFavicon(
  (color) => `
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
    <circle cx="16" cy="16" r="14" fill="${color}" />
  </svg>
`,
);
```

---

## CSS Utilities Reference

```css
/*
   BASELINE 2025: UTILITIES
   Configuration Providers.
*/

/* --- SURFACES --- */
/* Surface definitions are now auto-generated in generated-tokens.css */

/* --- SEMANTIC HUES --- */

.hue-success {
  --context-hue: var(--axm-hue-success);
  --context-chroma: var(--axm-chroma-success);

  --base-hue: var(--context-hue);
  --hue-adjust: 0;
  /* Apply a subtle tint to the surface background */
  --base-chroma: calc(var(--context-chroma) * 0.1);

  --default-fg-hue: var(--axm-hue-success);
  --override-fg-chroma: var(--axm-chroma-success);
}

.hue-warning {
  --context-hue: var(--axm-hue-warning);
  --context-chroma: var(--axm-chroma-warning);

  --base-hue: var(--context-hue);
  --hue-adjust: 0;
  /* Apply a subtle tint to the surface background */
  --base-chroma: calc(var(--context-chroma) * 0.1);

  --default-fg-hue: var(--axm-hue-warning);
  --override-fg-chroma: var(--axm-chroma-warning);
}

.hue-error {
  --context-hue: var(--axm-hue-error);
  --context-chroma: var(--axm-chroma-error);

  --base-hue: var(--context-hue);
  --hue-adjust: 0;
  /* Apply a subtle tint to the surface background */
  --base-chroma: calc(var(--context-chroma) * 0.1);

  --default-fg-hue: var(--axm-hue-error);
  --override-fg-chroma: var(--axm-chroma-error);
}

/* --- BORDERS --- */

.bordered {
  /* Default to decorative border from context */
  --computed-border-color: var(--computed-border-dec-color);
}

.border-interactive {
  /* Override for interactive borders from context */
  --computed-border-color: var(--computed-border-int-color);
}

/* --- MODIFIERS --- */

/* Elevation */
.shadow-sm {
  box-shadow: var(--axm-shadow-sm);
}
.shadow-md {
  box-shadow: var(--axm-shadow-md);
}
.shadow-lg {
  box-shadow: var(--axm-shadow-lg);
}
.shadow-xl {
  box-shadow: var(--axm-shadow-xl);
}

/* Focus */
.focus-ring:focus-visible {
  outline: 2px solid var(--axm-focus-ring-color);
  outline-offset: 2px;
}

/* Hue Adjustments */
.hue-brand {
  --base-hue: var(--axm-hue-brand);
  --hue-adjust: 0;
  /* Apply a subtle tint to the surface background */
  --base-chroma: calc(var(--axm-chroma-brand) * 0.1);

  --default-fg-hue: var(--axm-hue-brand);
  --override-fg-chroma: var(--axm-chroma-brand);
}

.hue-blue {
  --base-hue: var(--axm-hue-blue);
  --hue-adjust: 0;
  /* Apply a subtle tint to the surface background */
  --base-chroma: calc(var(--axm-chroma-blue) * 0.1);

  --default-fg-hue: var(--axm-hue-blue);
  --override-fg-chroma: var(--axm-chroma-blue);
}

/* Text Lightness Overrides */
.text-strong {
  /* No-op, resets to default for the surface */
}

.text-subtle {
  /* Apply computed chroma/hue to the subtle token */
  color: oklch(
    from var(--axm-text-subtle-token) l var(--computed-fg-C)
      var(--computed-fg-H)
  );
}

.text-subtler {
  /* Apply computed chroma/hue to the subtlest token */
  color: oklch(
    from var(--axm-text-subtlest-token) l var(--computed-fg-C)
      var(--computed-fg-H)
  );
}

.text-link {
  /* Links use the brand hue by default */
  color: oklch(from var(--computed-fg-color) l c var(--axm-hue-brand));
  text-decoration: underline;
  cursor: pointer;
}

/* --- STATES --- */

.state-disabled,
[disabled] {
  opacity: 0.5;
  pointer-events: none;
  /* Desaturate */
  filter: grayscale(1);
}

.state-selected,
[aria-selected="true"] {
  /* Selected state uses brand background */
  background-color: oklch(
    from var(--computed-surface) l c var(--axm-hue-brand)
  );
  /* Ensure text contrast on brand background might need adjustment, 
     but for now let's assume the lightness shift is handled by the surface logic 
     if we were to make this a full surface. 
     Since it's a modifier, we might need a specific token. 
     For Phase 1, let's keep it simple: Brand Border + Background Tint */
  border-color: oklch(from var(--computed-fg-color) l c var(--axm-hue-brand));
  background-color: oklch(
    from var(--computed-surface) l 0.05 var(--axm-hue-brand)
  );
}

/* Surface Adjustments */
.surface-vibrant {
  --surface-chroma-adjust: 0.02;
}

.surface-glass {
  backdrop-filter: blur(10px);
  background-color: oklch(from var(--computed-surface) l c h / 0.7) !important;
}

.hue-monochrome {
  --base-chroma: 0;
}

/* Content Overrides */
.fg-vibrant {
  --override-fg-chroma: 0.15;
}

/* --- SURFACE SPECIFIC OVERRIDES --- */

/* 
   Action Surfaces (Primary Buttons)
   When a hue is applied to an action surface, we want it to be "filled" (vibrant),
   not just tinted.
*/
.surface-action.hue-brand {
  --base-chroma: var(--axm-chroma-brand);
  /* Ensure text is white/light on dark brand background */
  --override-fg-chroma: 0;
}

.surface-action.hue-success {
  --base-chroma: var(--axm-chroma-success);
  --override-fg-chroma: 0;
}

.surface-action.hue-warning {
  --base-chroma: var(--axm-chroma-warning);
  --override-fg-chroma: 0;
}

.surface-action.hue-error {
  --base-chroma: var(--axm-chroma-error);
  --override-fg-chroma: 0;
}

.surface-action.hue-blue {
  --base-chroma: var(--axm-chroma-blue);
  --override-fg-chroma: 0;
}

.surface-action.hue-highlight {
  --base-chroma: var(--axm-chroma-highlight);
  --override-fg-chroma: 0;
}

/* --- KEY COLOR UTILITIES --- */

.text-error {
  color: var(--axm-key-error-color);
}
.text-warning {
  color: var(--axm-key-warning-color);
}
.text-success {
  color: var(--axm-key-success-color);
}
.text-brand {
  color: var(--axm-key-brand-color);
}

.bg-error {
  background-color: var(--axm-key-error-color);
}
.bg-warning {
  background-color: var(--axm-key-warning-color);
}
.bg-success {
  background-color: var(--axm-key-success-color);
}
.bg-brand {
  background-color: var(--axm-key-brand-color);
}

.stroke-error {
  stroke: var(--axm-key-error-color);
}
.stroke-warning {
  stroke: var(--axm-key-warning-color);
}
.stroke-success {
  stroke: var(--axm-key-success-color);
}
.stroke-brand {
  stroke: var(--axm-key-brand-color);
}

.accent-action {
  accent-color: var(--axm-surface-action-token);
}

.bg-strong {
  background-color: var(--axm-text-high-token);
}

.bg-subtle {
  background-color: var(--axm-text-subtle-token);
}

.text-inverse {
  color: var(--axm-surface-token);
}

.hover-text-error:hover {
  color: var(--axm-key-error-color);
}

```

---

## Configuration Schema

```json
{
  "$ref": "#/definitions/SolverConfig",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AnchorValue": {
      "additionalProperties": false,
      "properties": {
        "adjustable": {
          "type": "boolean"
        },
        "background": {
          "type": "number"
        }
      },
      "required": ["background"],
      "type": "object"
    },
    "Anchors": {
      "additionalProperties": false,
      "properties": {
        "dark": {
          "$ref": "#/definitions/ModeAnchors"
        },
        "light": {
          "$ref": "#/definitions/ModeAnchors"
        }
      },
      "required": ["light", "dark"],
      "type": "object"
    },
    "BezierCurve": {
      "additionalProperties": false,
      "properties": {
        "p1": {
          "items": {
            "type": "number"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "p2": {
          "items": {
            "type": "number"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        }
      },
      "required": ["p1", "p2"],
      "type": "object"
    },
    "BorderTargets": {
      "additionalProperties": false,
      "properties": {
        "critical": {
          "type": "number"
        },
        "decorative": {
          "type": "number"
        },
        "interactive": {
          "type": "number"
        }
      },
      "required": ["decorative", "interactive", "critical"],
      "type": "object"
    },
    "ConfigOptions": {
      "additionalProperties": false,
      "properties": {
        "prefix": {
          "description": "The prefix to use for CSS variables. Defaults to \"color-sys\".",
          "type": "string"
        },
        "selector": {
          "description": "The CSS selector to scope the variables to. Defaults to \":root\".",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ContrastOffsets": {
      "additionalProperties": false,
      "properties": {
        "dark": {
          "type": "number"
        },
        "light": {
          "type": "number"
        }
      },
      "type": "object"
    },
    "HueShiftConfig": {
      "additionalProperties": false,
      "properties": {
        "curve": {
          "$ref": "#/definitions/BezierCurve"
        },
        "maxRotation": {
          "description": "Maximum hue rotation in degrees.",
          "type": "number"
        }
      },
      "required": ["curve", "maxRotation"],
      "type": "object"
    },
    "ModeAnchors": {
      "additionalProperties": false,
      "properties": {
        "end": {
          "$ref": "#/definitions/AnchorValue"
        },
        "start": {
          "$ref": "#/definitions/AnchorValue"
        }
      },
      "required": ["start", "end"],
      "type": "object"
    },
    "ModeSpec": {
      "additionalProperties": false,
      "properties": {
        "background": {
          "type": "number"
        },
        "debug": {
          "additionalProperties": false,
          "properties": {
            "clamped": {
              "type": "boolean"
            },
            "targetContrast": {
              "type": "number"
            }
          },
          "required": ["targetContrast", "clamped"],
          "type": "object"
        },
        "fg-baseline": {
          "type": "number"
        },
        "fg-high": {
          "type": "number"
        },
        "fg-strong": {
          "type": "number"
        },
        "fg-subtle": {
          "type": "number"
        },
        "fg-subtlest": {
          "type": "number"
        }
      },
      "required": [
        "background",
        "fg-high",
        "fg-strong",
        "fg-baseline",
        "fg-subtle",
        "fg-subtlest"
      ],
      "type": "object"
    },
    "PaletteConfig": {
      "additionalProperties": false,
      "properties": {
        "hues": {
          "description": "List of hues to use for the palette. Defaults to a standard 10-color categorical scale.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "targetChroma": {
          "description": "Target chroma for chart colors. Defaults to ~0.12 (vibrant but not neon). Can be set to 'auto' to match the Action color.",
          "type": "number"
        },
        "targetContrast": {
          "description": "Target contrast against the page background (APCA). Lower values (e.g. 45-60) result in lighter colors in light mode (more pastel/vibrant) and darker colors in dark mode. Defaults to 60.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "Polarity": {
      "enum": ["page", "inverted"],
      "type": "string"
    },
    "PolarityAnchors": {
      "additionalProperties": false,
      "properties": {
        "inverted": {
          "$ref": "#/definitions/Anchors"
        },
        "keyColors": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A map of key color names to their values. Values can be:\n- A hex color string (e.g. \"#ff0000\")\n- A reference to another key color (e.g. \"danger\")",
          "type": "object"
        },
        "page": {
          "$ref": "#/definitions/Anchors"
        }
      },
      "required": ["page", "inverted", "keyColors"],
      "type": "object"
    },
    "PresetsConfig": {
      "additionalProperties": false,
      "properties": {
        "typography": {
          "$ref": "#/definitions/TypographyConfig"
        }
      },
      "type": "object"
    },
    "SolverConfig": {
      "additionalProperties": false,
      "properties": {
        "anchors": {
          "$ref": "#/definitions/PolarityAnchors"
        },
        "borderTargets": {
          "$ref": "#/definitions/BorderTargets"
        },
        "groups": {
          "items": {
            "$ref": "#/definitions/SurfaceGroup"
          },
          "type": "array"
        },
        "hueShift": {
          "$ref": "#/definitions/HueShiftConfig"
        },
        "options": {
          "$ref": "#/definitions/ConfigOptions"
        },
        "palette": {
          "$ref": "#/definitions/PaletteConfig"
        },
        "presets": {
          "$ref": "#/definitions/PresetsConfig"
        }
      },
      "required": ["anchors", "groups"],
      "type": "object"
    },
    "StateDefinition": {
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "offset": {
          "description": "Contrast offset relative to the parent surface. Positive = more contrast against text (lighter in light mode, darker in dark mode).",
          "type": "number"
        }
      },
      "required": ["name", "offset"],
      "type": "object"
    },
    "SurfaceConfig": {
      "additionalProperties": false,
      "properties": {
        "computed": {
          "additionalProperties": false,
          "properties": {
            "dark": {
              "$ref": "#/definitions/ModeSpec"
            },
            "light": {
              "$ref": "#/definitions/ModeSpec"
            }
          },
          "required": ["light", "dark"],
          "type": "object"
        },
        "contrastOffset": {
          "$ref": "#/definitions/ContrastOffsets",
          "description": "Shifts the surface's target contrast relative to its position in the sequence."
        },
        "description": {
          "type": "string"
        },
        "hue": {
          "description": "Target hue for this surface. Can be a number (0-360) or a reference to a key color (e.g. \"brand\").",
          "type": ["number", "string"]
        },
        "label": {
          "type": "string"
        },
        "override": {
          "additionalProperties": false,
          "description": "Manual hex override for the surface background color. If set, the solver will use this color instead of the calculated one.",
          "properties": {
            "dark": {
              "type": "string"
            },
            "light": {
              "type": "string"
            }
          },
          "type": "object"
        },
        "polarity": {
          "$ref": "#/definitions/Polarity"
        },
        "slug": {
          "type": "string"
        },
        "states": {
          "description": "Derivative surfaces (states) that are solved relative to this surface.",
          "items": {
            "$ref": "#/definitions/StateDefinition"
          },
          "type": "array"
        },
        "targetChroma": {
          "description": "Target chroma for this surface. If set, the solver will adjust Lightness to compensate for the HK effect.",
          "type": "number"
        }
      },
      "required": ["slug", "label", "polarity"],
      "type": "object"
    },
    "SurfaceGroup": {
      "additionalProperties": false,
      "properties": {
        "gapBefore": {
          "description": "Extra spacing (in contrast steps) before this group starts. Used to create visual separation between groups.",
          "type": "number"
        },
        "name": {
          "type": "string"
        },
        "surfaces": {
          "items": {
            "$ref": "#/definitions/SurfaceConfig"
          },
          "type": "array"
        }
      },
      "required": ["name", "surfaces"],
      "type": "object"
    },
    "TypeScaleConfig": {
      "additionalProperties": false,
      "properties": {
        "curve": {
          "$ref": "#/definitions/BezierCurve",
          "description": "Control points for the scaling curve."
        },
        "maxSize": {
          "description": "Max size in rem (e.g. 3.0).",
          "type": "number"
        },
        "minSize": {
          "description": "Base size in rem (e.g. 0.75).",
          "type": "number"
        },
        "steps": {
          "description": "Number of sizes to generate (e.g. 5 for xs, sm, base, lg, xl).",
          "type": "number"
        }
      },
      "required": ["steps", "minSize", "maxSize", "curve"],
      "type": "object"
    },
    "TypographyConfig": {
      "additionalProperties": false,
      "properties": {
        "fonts": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Font families. e.g. { mono: \"ui-monospace, ...\", sans: \"system-ui, ...\" }",
          "type": "object"
        },
        "scale": {
          "$ref": "#/definitions/TypeScaleConfig",
          "description": "Configuration for generating a type scale. If provided, this will override the `sizes` map."
        },
        "sizes": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Font sizes. e.g. { sm: \"0.875rem\", lg: \"1.125rem\" }",
          "type": "object"
        },
        "weights": {
          "additionalProperties": {
            "type": "number"
          },
          "description": "Font weights. e.g. { medium: 500, bold: 700 }",
          "type": "object"
        }
      },
      "type": "object"
    }
  }
}

```

---

