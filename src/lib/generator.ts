import {
  calculateHueShift,
  solveBorderAlpha,
  solveForegroundSpec,
} from "./math.ts";
import type {
  BorderTargets,
  HueShiftConfig,
  Mode,
  SurfaceGroup,
} from "./types.ts";

export function generateTokensCss(
  groups: SurfaceGroup[],
  backgrounds: Map<string, Record<Mode, number>>,
  hueShiftConfig?: HueShiftConfig,
  borderTargets?: BorderTargets
): string {
  const rootLines: string[] = [];
  const propertyLines: string[] = [];

  rootLines.push("/* AUTO-GENERATED by src/lib/generator.ts */");

  // Register global properties for smooth transitions
  propertyLines.push(`@property --surface-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}`);

  propertyLines.push(`@property --text-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}`);

  propertyLines.push(`@property --border-dec-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}`);

  propertyLines.push(`@property --border-int-token {
  syntax: "<color>";
  inherits: true;
  initial-value: transparent;
}`);

  const toNumber = (n: number): number => parseFloat(n.toFixed(4));

  for (const group of groups) {
    for (const surface of group.surfaces) {
      const bgLight = backgrounds.get(surface.slug)?.light ?? 0;
      const bgDark = backgrounds.get(surface.slug)?.dark ?? 0;

      const lightSpec = solveForegroundSpec(bgLight);
      const darkSpec = solveForegroundSpec(bgDark);

      const lightShift = calculateHueShift(bgLight, hueShiftConfig);
      const darkShift = calculateHueShift(bgDark, hueShiftConfig);

      // Generate the Class Definition
      rootLines.push(`.surface-${surface.slug} {`);

      // 1. Surface Token
      rootLines.push(
        `  --surface-token: light-dark(
    oklch(${toNumber(bgLight)} 0 ${toNumber(lightShift)}),
    oklch(${toNumber(bgDark)} 0 ${toNumber(darkShift)})
  );`
      );

      // 2. Text Token
      rootLines.push(
        `  --text-token: light-dark(
    oklab(${toNumber(lightSpec["fg-high"])} ${toNumber(
          lightSpec["fg-subtle"]
        )} ${toNumber(lightSpec["fg-subtlest"])}),
    oklab(${toNumber(darkSpec["fg-high"])} ${toNumber(
          darkSpec["fg-subtle"]
        )} ${toNumber(darkSpec["fg-subtlest"])})
  );`
      );

      // 3. Border Tokens
      if (borderTargets) {
        const solveBorder = (
          bgL: number,
          textL: number,
          target: number
        ): number => solveBorderAlpha(bgL, textL, target);

        const lightDec = solveBorder(
          bgLight,
          lightSpec["fg-strong"],
          borderTargets.decorative
        );
        const darkDec = solveBorder(
          bgDark,
          darkSpec["fg-strong"],
          borderTargets.decorative
        );
        const lightInt = solveBorder(
          bgLight,
          lightSpec["fg-strong"],
          borderTargets.interactive
        );
        const darkInt = solveBorder(
          bgDark,
          darkSpec["fg-strong"],
          borderTargets.interactive
        );

        const lightBorderL = lightSpec["fg-strong"];
        const darkBorderL = darkSpec["fg-strong"];

        rootLines.push(
          `  --border-dec-token: light-dark(
    oklch(${toNumber(lightBorderL)} 0 0 / ${toNumber(lightDec)}),
    oklch(${toNumber(darkBorderL)} 0 0 / ${toNumber(darkDec)})
  );`
        );

        rootLines.push(
          `  --border-int-token: light-dark(
    oklch(${toNumber(lightBorderL)} 0 0 / ${toNumber(lightInt)}),
    oklch(${toNumber(darkBorderL)} 0 0 / ${toNumber(darkInt)})
  );`
        );
      }

      rootLines.push(`}`); // End class

      // States (Hover/Active)
      if (surface.states) {
        surface.states.forEach((state) => {
          const stateSlug = `${surface.slug}-${state.name}`;
          const bgState = backgrounds.get(stateSlug);

          if (bgState) {
            // We generate a modifier class? Or pseudo-class?
            // The config says "states: [{name: 'hover'}]".
            // Usually this maps to `.surface-card:hover`.
            // But sometimes it might be a class `.surface-card-selected`.
            // Let's assume pseudo-classes for standard names, and classes for others?
            // The original code generated `--surface-card-hover-token`.
            // And `utilities.css` mapped `.surface-card:hover` to that token.

            // Here we can generate:
            // .surface-card:hover { --surface-token: ... }

            const selector =
              state.name === "hover" || state.name === "active"
                ? `.surface-${surface.slug}:${state.name}`
                : `.surface-${surface.slug}-${state.name}`; // e.g. .surface-card-selected

            const lightStateShift = calculateHueShift(
              bgState.light,
              hueShiftConfig
            );
            const darkStateShift = calculateHueShift(
              bgState.dark,
              hueShiftConfig
            );

            rootLines.push(`${selector} {`);
            rootLines.push(
              `  --surface-token: light-dark(
    oklch(${toNumber(bgState.light)} 0 ${toNumber(lightStateShift)}),
    oklch(${toNumber(bgState.dark)} 0 ${toNumber(darkStateShift)})
  );`
            );
            rootLines.push(`}`);
          }
        });
      }
      rootLines.push("");
    }
  }

  return [...propertyLines, "", ...rootLines].join("\n");
}
