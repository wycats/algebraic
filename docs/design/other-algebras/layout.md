# Algebraic Layout System: Standard Specification

**Version:** 2.2.0-CR (Candidate Recommendation)
**Status:** Baseline 2026 Ready
**Context:** Core Design System / Layout Engine

## 1. Introduction and Motivation

Modern web layout is often fragile. In traditional CSS development, layout logic is frequently scattered across disparate classes, utilizing ad-hoc margins, magic numbers, and media queries. This leads to "fragile styling," where a change in one component (e.g., increasing a button's margin) unexpectedly breaks the layout of a distant ancestor.

The **Algebraic Layout System** seeks to resolve this by decoupling **Geometry** (the arrangement of elements) from **Physics** (the spacing and sizing of elements). It proposes a closed algebra of **12 Layout Primitives** that serve as the sole mechanism for arranging UI elements.

By treating layout as a deterministic function of content and container constraints, rather than a series of visual tweaks, we achieve:

1. **Component Isolation:** Components have no external side effects (margins).

2. **Predictable Composition:** Primitives can be nested infinitely without breaking spatial invariants.

3. **Algorithmic Consistency:** Spacing and typography scale mathematically across viewports, eliminating the need for manual breakpoint adjustments.

## 2. Core Axioms (The Physics)

The system is governed by three immutable laws. These are not merely best practices; they are the constraints required to make the algebra valid. Deviating from these axioms invalidates the stability guarantees of the system.

### Axiom I: The Law of Enclosure (No Margins)

**Statement:** A component must strictly enclose its bounding box.
**Constraint:** The CSS `margin` property is strictly forbidden on all child components.
**Mechanism:** Layout space is exclusively generated by the _Container_ via `gap` (space between items) and `inset` (internal padding).

**Rationale:**
In traditional CSS, margins "collapse" in complex ways, and elements push against their neighbors. This creates a dependency between siblings. By banning margins, we ensure that a component is mathematically portable. A Button component has `Width` and `Height`. It has zero "influence" on the surrounding space. If space is required, the parent `Stack` or `Cluster` must explicitly provide it via the `gap` property.

### Axiom II: The Two-Cue Rule (Visual Hierarchy)

**Statement:** A hierarchy promotion requires a change in at least two distinct perceptual channels.
**Constraint:** A semantic rank increase (e.g., promoting Body text to a Sidebar header) requires changing $\Delta Cues \ge 2$ from the set: `{Size, Color, Shape, Position}`.

**Rationale:**
Design systems often rely on subtle cues (e.g., slightly bolder text) to denote importance. Research indicates that under poor lighting conditions or with cognitive impairment, single cues are often missed. By enforcing a multi-channel difference (e.g., Bolder _and_ Darker, or Larger _and_ Spaced), we ensure robust, accessible hierarchy that survives responsive layout shifts.

### Axiom III: Intrinsic Adaptation

**Statement:** Layouts must adapt to Content ($C$) first, Container ($K$) second, and Viewport ($V$) last.
**Constraint:** Explicit viewport media queries (`@media`) are forbidden for component layout decisions. Use Container Queries (`@container`) or Intrinsic Switching logic.

**Rationale:**
A component does not know the size of the screen; it only knows the size of the slot it occupies. A "Card" component might be in a wide main column or a narrow sidebar. Using viewport queries causes the card to break in the narrow sidebar. Using Intrinsic Adaptation ensures the component renders correctly based on the _actual_ space available to it.

## 3. The Spacing Scalar Field (The Breathing Grid)

In this system, spacing is not defined by static pixel values (e.g., `20px`). Instead, spacing is a **Fluid Function** derived from the structural relationship between elements and the current viewport width. We call this "The Breathing Grid."

**The Master Formula:**

$$
Value(t) = [Min + (Max - Min) \cdot E(t)] \cdot Density
$$

- $t$ **(Normalized Viewport):** A value from $0.0 \to 1.0$ representing the progression from the minimum supported width (320px) to the maximum (1440px).

- $E(t)$ **(Shared Easing):** We use an **Ease-Out Quad** curve: $1 - (1 - t)^2$. This ensures that spacing expands rapidly as we leave mobile widths, creating immediate breathing room, before settling into a luxurious spacing on desktop.

- $Density$**:** A scalar user preference ($0.75 \dots 1.25$) allowing for Compact or Spacious modes without refactoring.

### 3.1 Token Definition & Usage

| Role           | Token         | Semantic Usage                                                  | $\Delta$ Level |
| -------------- | ------------- | --------------------------------------------------------------- | -------------- |
| **Atomic**     | `gap-inline`  | **Fused.** Elements functioning as a single unit (Icon + Text). | 0              |
| **Peer**       | `gap-intra`   | **Close.** Distinct elements within a group (List items).       | 1              |
| **Distinct**   | `gap-inter`   | **Separated.** Distinct groups or blocks (Card + Card).         | 2              |
| **Thematic**   | `gap-section` | **Divided.** Major shifts in context (Feature Band vs Footer).  | 3              |
| **Structural** | `gap-region`  | **Isolated.** Architectural boundaries (Nav vs Main).           | 4              |

## 4. The Primitive Catalog (The Periodic Table)

Each primitive is a specialized operator defined by its **Algebraic Contract** (Behavior) and **Gravity Matrix** (Alignment).

### Group A: The Flows (Rhythm)

These primitives manage the placement of content based on its natural size.

#### 1. Stack (Vertical Flow)

**Description:** The fundamental primitive for vertical rhythm. Arranges children sequentially along the Y-axis.
**Algebraic Contract:** The height of a Stack is the sum of its children's heights plus the accumulated gaps.

$$
H_{total} = \sum H_{child} + (N-1) \times Gap
$$

**Gravity:** Defaults to `stretch` (children fill the width). Can be set to `start`, `center`, or `end` to align children horizontally without stretching.

#### 2. Shelf (Horizontal Flow)

**Description:** A strict single-row layout. Useful for toolbars and navbars.
**Algebraic Contract:** Children are arranged along the X-axis. This primitive **never wraps**.
**Constraint:** Because wrapping is forbidden, overflow logic must be explicit. The implementer must decide whether to `clip` (hide overflow) or `scroll` (allow horizontal panning).
**Gravity:** Supports `baseline` alignment, which is critical for aligning text of different sizes in a toolbar.

#### 3. Cluster (Wrapping Flow)

**Description:** A fluid layout for inline items like tags, pills, or variable-width cards.
**Algebraic Contract:** Children are arranged along the X-axis. If a child would overflow the container ($X_{cursor} + W_{child} > W_{container}$), it is moved to the start of the next line ($Y_{cursor} += H_{row} + Gap$).
**Usage Note:** Often used with `gap-inline` for tight groupings of metadata.

### Group B: The Grids (Space Division)

These primitives enforce specific geometric divisions of the available space.

#### 4. Library (Uniform Columns)

**Description:** A strict grid where every column has equal width, regardless of the content inside it.
**Algebraic Contract:** Divides space into $N$ equal tracks.

$$
W_{col} = (W_{container} - (N-1) \times Gap) / N
$$

**Usage:** Image galleries, product catalogs, or any list where visual rhythm must be perfectly uniform.

#### 5. Bookcase (Justified Rows)

**Description:** A masonry-like layout where items are organized into rows. Unlike the Library, items in a Bookcase can have different widths.
**Algebraic Contract:** Rows are independent. In each row, items grow to fill the remaining space.
**Usage:** Tag clouds, dashboard widgets of varying importance, or "justified" image galleries (like Google Photos).

#### 6. Split (Weighted Columns)

**Description:** Divides space into tracks defined by specific ratios.
**Algebraic Contract:** Widths are calculated via vector projection.

$$
W_i = W_{total} \times (r_i / \sum \vec{R})
$$

**Usage:** The "Golden Ratio" layout (1:1.618), or classic application panels (e.g., `[1, 3]` for Sidebar/Main).

### Group C: Architecture (Scaffolding)

#### 7. Cover (Centering)

**Description:** A specialized layout for centering content vertically while maintaining stable anchors.
**Algebraic Contract:** Anchors $C_{top}$ and $C_{bottom}$ adhere to the edges. $C_{main}$ is centered in the remaining available height ($H_{remain}$).
**Usage:** Login screens, "Hero" marketing sections, or empty states.

#### 8. Sidebar (Fixed + Fluid)

**Description:** A two-pane layout partitioning space into an Invariant section ($Fixed$) and a Variant section ($Fluid$).
**Constraint:** The Fluid side must utilize `min-width: 0`. This defensive CSS technique prevents long strings (like URLs) from forcing the flex container to expand beyond the viewport width.

#### 9. Overlay (Z-Axis)

**Description:** A primitive that escapes the Boundary Invariant. It places content on the Z-axis, effectively creating a new layer above the page.
**Capabilities:** This is a "heavy" primitive. It implicitly manages Focus Trapping (keeping keyboard focus inside the overlay), Backdrop blurring, and "Esc-to-close" behavior.

### Group D: Logic (Behavior)

#### 10. Switcher (Responsive)

**Description:** The core responsive operator. It switches the layout logic based on available width.
**Contract:** If the content fits side-by-side, render as `Shelf`. If it collides or is too narrow, render as `Stack`.
**Strategy:**

- **Strategy A (Tokenized):** Uses a Container Query (`@container`) to switch at a specific token width.

- **Strategy B (Intrinsic):** Uses the Layout Controller to switch exactly when content collides.

#### 11. Ladder (Ranked)

**Description:** A semantic layout for Ranked Lists.
**Contract:** $Ladder(Head, Tail) \equiv Shelf(Head, Stack(Tail))$
**Usage:** News feeds (Hero article + list of links), or Leaderboards (Top user + list of runners up).

#### 12. Inset (Padding)

**Description:** The only primitive allowed to create internal spacing.
**Algebraic Contract:** Applies uniform or axial padding based on the Spacing Tokens defined in Section 3.1.

$$
Box_{inner} = Box_{outer} - 2 \times Padding
$$

## 5. The Layout Controller (Implementation Reference)

To achieve **True Intrinsic Switching**—where a layout changes exactly when its content runs out of space, rather than at an arbitrary pixel value—we cannot rely on pure CSS. We use a minimal JavaScript singleton called the `LayoutController`.

### 5.1 The Algorithm

The goal is to avoid "Layout Thrashing" (rapid read/write cycles).

1. **Registration:** When a Switcher component mounts, it registers itself with the Controller.

2. **Calibration:** The Controller performs a "Zero-Cost Layout Check." It temporarily renders the children at `width: min-content` to calculate their total natural width. This value is cached as the **Intrinsic Threshold**.

3. **Observation:** A single `ResizeObserver` watches the container.

4. **Reaction:** When the observer fires, we compare the current width to the cached Threshold.

   - If $Width_{container} \le Threshold$: The content is too wide to fit. Add class `.is-stacked`.

   - If $Width_{container} > Threshold$: There is enough room. Remove class `.is-stacked`.

### 5.2 TypeScript Interface

```typescript
interface LayoutController {
  // Registers a container for intrinsic observation
  observe(element: HTMLElement): void;

  // Forces re-calibration (call on font-load or content change)
  recalibrate(element: HTMLElement): void;

  // Clean up
  disconnect(): void;
}
```

## 6\. Stability Invariants (QA Checklist)

For a layout to be considered "Algebraically Sound," it must pass these five Unit Tests.

1.  **Boundary Invariant:**

    - _Test:_ Apply `overflow: hidden` to the primitive container.

    - _Pass Condition:_ No child content should be clipped (unless the primitive is explicitly designed to clip, like `Shelf`). If content is clipped, the primitive is failing to calculate its dimensions correctly.

2.  **Isolation Invariant:**

    - _Test:_ Nest a `Stack(gap: 0)` inside a `Stack(gap: 50)`.

    - _Pass Condition:_ The inner gap must be exactly 0 pixels. The outer gap must not "leak" into the inner container (a common failure mode of CSS margin collapse).

3.  **Dimensional Invariant:**

    - _Test:_ Place a contiguous string of text (no spaces) inside a child element.

    - _Pass Condition:_ The text should wrap or truncate. It must **not** force the container to become wider than its parent. This validates the `min-width: 0` constraint on flex children.

4.  **Identity Invariant:**

    - _Test:_ Render the primitive with an empty array of children: `children={[]}`.

    - _Pass Condition:_ The computed height of the element must be 0px. It should not occupy any visual space.

5.  **Hierarchy Monotonicity:**

    - _Test:_ Create a `Sidebar` and place a `Promote`d card inside it. Overlap them using negative margins (for testing only).

    - _Pass Condition:_ The Promoted card must visually obscure the Sidebar's border. This confirms that the Stacking Context is correctly ordered ($Z_{child} \ge Z_{parent}$).

## 7\. X-Ray Debugging Protocol

To aid development, we define a standardized "X-Ray" mode. This allows developers to see the invisible algebra (containers, gaps, and flows) that dictates the layout.

```css
:root {
  --debug-flow: #007aff; /* Blue: Flows (Stack, Shelf) */
  --debug-grid: #ff3b30; /* Red: Grids (Library, Split) */
  --debug-arch: #34c759; /* Green: Architecture (Sidebar, Cover) */
  --debug-gap: #ffd60a; /* Yellow: Spacing */
}

/* Base Debug Outline */
body[data-debug] [data-layout] {
  outline: 1px dashed var(--debug-color, #ccc);
  position: relative;
}

/* Visualize Gaps as a Hatch Pattern */
body[data-debug] [data-layout]::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  background-image: repeating-linear-gradient(
    45deg,
    var(--debug-gap) 0,
    var(--debug-gap) 1px,
    transparent 0,
    transparent 8px
  );
  opacity: 0.1;
  z-index: 9999;
}
```
